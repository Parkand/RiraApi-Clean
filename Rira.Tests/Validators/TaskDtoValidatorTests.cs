using Xunit;
using FluentAssertions;
using Rira.Application.Common;

namespace Rira.Tests.Application.Common
{
    /// <summary>
    /// ✅ کلاس تست واحد برای ResponseModel<T>
    /// -----------------------------------------------------------
    /// این کلاس وظیفه دارد منطق و رفتار پایه‌ی کلاس ResponseModel در پروژه ریرا را بررسی کند.
    /// ResponseModel یکی از مهم‌ترین اجزای معماری Clean است چون ساختار خروجی تمامی سرویس‌ها را استاندارد می‌سازد.
    /// هر پاسخ یک سرویس (موفق یا ناموفق) باید در قالب این مدل برگردد تا منطق تست‌ها و کلاینت‌ها یکنواخت بماند.
    ///
    /// در این تست، رفتارهای زیر آزمایش می‌شوند:
    ///   1. مقداردهی صحیح سازنده (Constructor)
    ///   2. عملکرد متدهای ایستا‌ی Ok و Fail
    ///   3. بررسی مقادیر پیش‌فرض در سازنده‌ی بدون آرگومان
    ///   4. تطابق رفتار با انتظارات معماری و تست‌های سرویس
    ///
    /// 📘 هدف:
    /// اطمینان از اینکه هر زمان ResponseModel ساخته شود،
    /// فیلدهای Success، Message و Data دقیق و مطابق انتظار مقداردهی می‌شوند.
    /// </summary>
    public class ResponseModelTests
    {
        // ======================================================================================================
        // 🟢 تست ۱: بررسی سازنده‌ی سه‌پارامتری
        // ------------------------------------------------------------------------------------------------------
        // در این تست، نمونه‌ای از ResponseModel با حالت "موفقیت‌آمیز" ساخته می‌شود و بررسی می‌کنیم که آیا
        // تمامی مقادیر (Success, Message, Data) درست مقداردهی شده‌اند یا خیر.
        // ======================================================================================================
        [Fact]
        public void Constructor_Should_Assign_Properties_Correctly()
        {
            // 🔧 داده‌ی نمونه‌ی تست: در واقع یک شیء فرضی مشابه DTO را شبیه‌سازی می‌کنیم.
            var fakeDto = new { Id = 1, Title = "تسک تستی" };

            // 🏗️ ساخت ResponseModel با پارامترهای ورودی مشخص
            var response = new ResponseModel<object>(true, "عملیات با موفقیت انجام شد", fakeDto);

            // ✅ بررسی تک‌تک ویژگی‌ها با FluentAssertions (که خواناتر از Assert ساده است)
            response.Success.Should().BeTrue("چون عملیات موفق اعلام شده است.");
            response.Message.Should().Be("عملیات با موفقیت انجام شد", "پیام باید دقیقاً همان متن داده‌شده باشد.");
            response.Data.Should().NotBeNull("در پاسخ موفق باید داده وجود داشته باشد.");
            response.Data.Should().Be(fakeDto, "داده باید دقیقاً با ورودی سازنده برابر باشد.");
        }

        // ======================================================================================================
        // 🔴 تست ۲: سازنده‌ی سه‌پارامتری در حالت شکست (Failure)
        // ------------------------------------------------------------------------------------------------------
        // در این حالت، انتظار داریم Success برابر false باشد و فیلد Data مقدار null بگیرد.
        // ======================================================================================================
        [Fact]
        public void Constructor_Should_Handle_Failure_Correctly()
        {
            // ⚙️ ساخت مدل پاسخ ناموفق
            var response = new ResponseModel<string>(false, "خطا در پردازش داده", null);

            // ✅ بررسی وضعیت‌ها
            response.Success.Should().BeFalse("در حالت خطا باید Success=false باشد.");
            response.Message.Should().Be("خطا در پردازش داده", "پیام خطا باید همان متن داده‌شده باشد.");
            response.Data.Should().BeNull("در حالت خطا نباید داده وجود داشته باشد.");
        }

        // ======================================================================================================
        // 🟩 تست ۳: متد ایستا‌ی Ok
        // ------------------------------------------------------------------------------------------------------
        // متد Ok برای تولید پاسخ موفقیت‌آمیز به‌کار می‌رود و باید Success=true باشد.
        // همچنین باید داده و پیام درست ذخیره شوند.
        // ======================================================================================================
        [Fact]
        public void Ok_Static_Method_Should_Create_Success_Response()
        {
            // 🧱 داده‌ی فرضی خروجی موفقیت‌آمیز (مثل Example DTO)
            var dto = new { Id = 5, Title = "تسک نمونه" };

            // 🧩 فراخوانی متد ایستا‌ی Ok
            var response = ResponseModel<object>.Ok("تسک با موفقیت ثبت شد", dto);

            // ✅ بررسی مقداردهی نتیجه
            response.Success.Should().BeTrue("در متد Ok باید مقدار Success=true باشد.");
            response.Message.Should().Contain("موفقیت", "پیام باید شامل کلمه‌ی موفقیت باشد.");
            response.Data.Should().Be(dto, "داده خروجی باید همان شیء ورودی باشد.");
        }

        // ======================================================================================================
        // 🟥 تست ۴: متد ایستا‌ی Fail
        // ------------------------------------------------------------------------------------------------------
        // این متد برای تولید پاسخ خطا استفاده می‌شود.
        // انتظار داریم Success=false و Data=null باشد و پیام دقیقاً همان متن داده‌شده شود.
        // ======================================================================================================
        [Fact]
        public void Fail_Static_Method_Should_Create_Failure_Response()
        {
            // 🧩 ساخت پاسخ خطا با متد Fail (استفاده از نوع Reference برای تست اطمینان از null)
            var response = ResponseModel<object>.Fail("آیتم مورد نظر یافت نشد");

            // ✅ بررسی خروجی
            response.Success.Should().BeFalse("متد Fail باید حالت شکست را اعلام کند.");
            response.Data.Should().BeNull("در پاسخ خطا نباید داده‌ای وجود داشته باشد.");
            response.Message.Should().Be("آیتم مورد نظر یافت نشد");
        }

        // ======================================================================================================
        // 🟣 تست ۵: بررسی رفتار ترکیبی - دوتاستی (موفق/خطا)
        // ------------------------------------------------------------------------------------------------------
        // در این بخش، هم متد Ok و هم Fail اجرا می‌شوند تا رفتار ترکیبی سیستم بررسی شود.
        // این تست شباهت زیادی به کاربرد واقعی در سرویس‌ها دارد.
        // ======================================================================================================
        [Fact]
        public void Ok_And_Fail_Combination_Should_Behave_Correctly()
        {
            // ✅ حالت موفقیت
            var successData = new { Id = 101, Title = "ثبت انجام شد" };
            var okResponse = ResponseModel<object>.Ok("عملیات با موفقیت انجام شد", successData);

            okResponse.Success.Should().BeTrue();
            okResponse.Message.Should().Contain("موفقیت");
            okResponse.Data.Should().Be(successData);

            // ❌ حالت خطا
            var failResponse = ResponseModel<object>.Fail("خطا در دریافت داده");

            failResponse.Success.Should().BeFalse();
            failResponse.Data.Should().BeNull();
            failResponse.Message.Should().Be("خطا در دریافت داده");
        }

        // ======================================================================================================
        // ⚪ تست ۶: سازنده‌ی پیش‌فرض (بدون آرگومان)
        // ------------------------------------------------------------------------------------------------------
        // این تست بررسی می‌کند مقادیر پیش‌فرض کلاس در زمان ساخت بدون ورودی چیست.
        // انتظار داریم Success=false و Message رشته‌ی خالی باشد.
        // ======================================================================================================
        [Fact]
        public void Default_Constructor_Should_Have_Correct_Defaults()
        {
            // ساخت ResponseModel بدون هیچ پارامتر ورودی
            var response = new ResponseModel<string>();

            // 🔍 بررسی مقادیر پیش‌فرض
            response.Success.Should().BeFalse("در سازنده‌ی پیش‌فرض هیچ مقداردهی‌ای صورت نگرفته است.");
            response.Message.Should().BeEmpty("در کلاس اصلی مقدار اولیه‌ی Message برابر string.Empty تعریف شده.");
            response.Data.Should().BeNull("داده‌ای وارد نشده، پس باید null باشد.");
        }
    }
}
